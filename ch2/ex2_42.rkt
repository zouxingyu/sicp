#lang sicp
(define (safe? rest)
  (let ((queen (car rest)))
    (define (iter positions right-diagonal left-diagonal)
      (cond ((null? positions) #t)
            ((= queen (car positions)) #f)
            ((= right-diagonal (car positions)) #f)
            ((= left-diagonal (car positions)) #f)
            (else (iter (cdr positions) (- right-diagonal 1) (+ left-diagonal 1)))))
    (iter (cdr rest) (- queen 1) (+ queen 1))))
(define (adjoin-position new-row rest-of-queens)
  (cons new-row rest-of-queens))
(define (enumerate-interval i j)
  (if (> i j)
      nil
      (cons i (enumerate-interval (+ i 1) j))))
(define (filter f seq)
  (if (null? seq)
      nil
      (if (f (car seq))
          (cons (car seq) (filter f (cdr seq)))
          (filter f (cdr seq)))))
(define (accumulate op init seq)
  (cond ((null? seq) init)
        (else (op (car seq)
                  (accumulate op init (cdr seq))))))
(define (flatmap proc seq)
  (accumulate append nil (map proc seq)))
 (define (queens board-size) 
     (define (queen-cols k) 
         (if (= k 0) (list nil) (filter (lambda (positions) (safe? positions))
                                        (flatmap (lambda (rest) (map (lambda (x) (adjoin-position x rest))
                                                                     (enumerate-interval 1 board-size))) (queen-cols (- k 1)))))) 
     (queen-cols board-size)) 